//******************************************************************************
// Author: Rafael Geraldeli Rossi
// E-mail: rgr.rossi at gmail com
// Last-Modified: February 27, 2015
// Description: Class to perform Inctive Semi-Supervised Lerning and Evaluation.
//              The classification models are generated considering Documen-
//              term and Term-Term relations.  
//******************************************************************************

package TCT;

import TCTAlgorithms.InductiveSemiSupervised.InductiveSemiSupervisedClassifier;
import TCTAlgorithms.InductiveSemiSupervised.TCHN_DocTerm_TermTerm_InductiveSemiSupervised_ID;
import TCTAlgorithms.InductiveSemiSupervised.TCTN_TermTerm_InductiveSemiSupervised;
import TCTNetworkGeneration.TermNetworkGeneration;
import TCTParameters.Parameters_TermNetwork;
import TCTParameters.SemiSupervisedLearning.Parameters_IMHN;
import TCTConfigurations.SemiSupervisedLearning.SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations;
import TCTParameters.SemiSupervisedLearning.Parameters_LLGC;
import TCTStructures.Neighbor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Random;
import weka.core.Attribute;
import weka.core.Instance;
import weka.core.Instances;
import weka.core.converters.ConverterUtils;

public class SemiSupervisedInductiveClassification_DocTerm_TermTerm {
    
    /*Function to read the data (document-term matrix and term probabilities) and build networks with Document-term and Term-Term relations. */
    public static  void learning(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration){
        
        File fileArff = new File(configuration.getArff()); // Document-Term Matrix 
        File fileProb = new File(configuration.getArqProb()); // Term-Term probabilities generated by the class TCTInterfaces.Interface_Utilities_TermTermProbabilities
        File dirSaida = new File(configuration.getDirSaida()); // Directory do store evaluation results
        
        int numTerms = 0;
        
        if(!fileArff.getAbsolutePath().endsWith(".arff")){
            System.out.println("Invalid ARF file");
            return;
        }
        if(!fileProb.getAbsolutePath().endsWith(".prb")){
            System.out.println("Invalid probability file");
            return;
        }
        if(!dirSaida.exists()){
            System.out.println("Output directory does not exist");
            return;
        }
        
        System.out.println(fileArff.getAbsolutePath());
        System.out.println("Loading ARFF file");
        Instances dataOriginal = null;
        int numClasses = 0;
        try{
            //Reading document-term matrix
            ConverterUtils.DataSource trainSource = new ConverterUtils.DataSource(fileArff.getAbsolutePath().toString()); //Carregando arquivo de Dados
            dataOriginal = trainSource.getDataSet();
            
            Attribute classAtt = null;
            numTerms = dataOriginal.numAttributes()-1;
            classAtt = dataOriginal.attribute(numTerms); //Setting the last feature as class
            dataOriginal.setClass(classAtt);
            numClasses = classAtt.numValues();

            for(int j=0;j<numClasses;j++){
                System.out.println(j + ": " + classAtt.value(j));
            }

        }catch(OutOfMemoryError e){
            configuration.getEmail().getContent().append("OutOfMemory!!!!");
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }catch(Exception e){
            System.err.println("Error when reading document-term matrix.");
            configuration.getEmail().getContent().append(e.getMessage());
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }
        
        StringBuilder outputFile = new StringBuilder();
        outputFile.append(configuration.getDirSaida());
        outputFile.append("/");
        outputFile.append(dataOriginal.relationName());
        outputFile.append("_SemiSupervisedInductiveClassification_DTandorTT_");
                
        //Generating relations among terms
        if(configuration.isSupportNetwork()){
            StringBuilder outputFilePar = new StringBuilder();
            outputFilePar.append("Support");
            outputFilePar.append("_");
            Parameters_TermNetwork parametersSupportNetwork = configuration.getParametersSupportNetwork();
            if(parametersSupportNetwork.getThresholdNetwork()){
                for(int lim=0;lim<parametersSupportNetwork.getThresholds().size();lim++){
                    double threshold = parametersSupportNetwork.getThreshold(lim);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateSupportNetworkThreshold(fileProb,numTerms,threshold,parametersSupportNetwork.getRelative());
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_Threshold_" + threshold + "_",dataOriginal,numClasses);
                }    
            }
            if(parametersSupportNetwork.getNetworkTopK()){
                for(int topK=0;topK<parametersSupportNetwork.getKs().size();topK++){
                     int k = parametersSupportNetwork.getK(topK);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateSupportNetworkTopK(fileProb,numTerms,k);
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_TopK_" + k + "_",dataOriginal,numClasses);
                }
            }
            
        }
        if(configuration.isMutualInformationNetwork()){
            StringBuilder outputFilePar = new StringBuilder();
            outputFilePar.append("MutualInformation");
            outputFilePar.append("_");
            Parameters_TermNetwork parametersMutualInformationNetwork = configuration.getParametersMutualInformationNetwork();
            if(parametersMutualInformationNetwork.getThresholdNetwork()){
                for(int lim=0;lim<parametersMutualInformationNetwork.getThresholds().size();lim++){
                    double threshold = parametersMutualInformationNetwork.getThreshold(lim);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateMutualInformationNetworkThreshold(fileProb,numTerms,threshold,parametersMutualInformationNetwork.getRelative());
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_Threshold_" +threshold + "_",dataOriginal,numClasses);
                }    
            }
            if(parametersMutualInformationNetwork.getNetworkTopK()){
                for(int topK=0;topK<parametersMutualInformationNetwork.getKs().size();topK++){
                    int k = parametersMutualInformationNetwork.getK(topK);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateMutualInformationNetworkTopK(fileProb,numTerms,k);
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_TopK_" + k + "_",dataOriginal,numClasses);
                }
            }
        }
        if(configuration.isKappaNetwork()){
            StringBuilder outputFilePar = new StringBuilder();
            outputFilePar.append("Kappa");
            outputFilePar.append("_");
            Parameters_TermNetwork parametersKappaNetwork = configuration.getParametersKappaNetwork();
            if(parametersKappaNetwork.getThresholdNetwork()){
                for(int lim=0;lim<parametersKappaNetwork.getThresholds().size();lim++){
                    double threshold = parametersKappaNetwork.getThreshold(lim);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateKappaNetworkThreshold(fileProb,numTerms,threshold,parametersKappaNetwork.getRelative());
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_Threshold_" +threshold + "_",dataOriginal,numClasses);
                }    
            }
            if(parametersKappaNetwork.getNetworkTopK()){
                for(int topK=0;topK<parametersKappaNetwork.getKs().size();topK++){
                    int k = parametersKappaNetwork.getK(topK);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateKappaNetworkTopK(fileProb,numTerms,k);
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_TopK_" + k + "_",dataOriginal,numClasses);
                }
            }    
        }
        if(configuration.isShapiroNetwork()){
            StringBuilder outputFilePar = new StringBuilder();
            outputFilePar.append("Shapiro");
            outputFilePar.append("_");
            Parameters_TermNetwork parametersShapiroNetwork = configuration.getParametersShapiroNetwork();
            if(parametersShapiroNetwork.getThresholdNetwork()){
                for(int lim=0;lim<parametersShapiroNetwork.getThresholds().size();lim++){
                    double threshold = parametersShapiroNetwork.getThreshold(lim);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateShapiroNetworkThreshold(fileProb,numTerms,threshold,parametersShapiroNetwork.getRelative());
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_Threshold_" + threshold + "_",dataOriginal,numClasses);
                }    
            }
            if(parametersShapiroNetwork.getNetworkTopK()){
                for(int topK=0;topK<parametersShapiroNetwork.getKs().size();topK++){
                    int k = parametersShapiroNetwork.getK(topK);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateShapiroNetworkTopK(fileProb,numTerms,k);
                    learning(configuration,adjacencyListTerms, outputFile.toString(), outputFilePar.toString() + "_TopK_" + k + "_",dataOriginal,numClasses);
                }
            }    
        }
        if(configuration.isYulesQNetwork()){
            StringBuilder outputFilePar = new StringBuilder();
            outputFilePar.append("Yule's Q");
            outputFilePar.append("_");
            Parameters_TermNetwork parametersYulesQNetwork = configuration.getParametersYulesQNetwork();
            if(parametersYulesQNetwork.getThresholdNetwork()){
                for(int lim=0;lim<parametersYulesQNetwork.getThresholds().size();lim++){
                    double threshold = parametersYulesQNetwork.getThreshold(lim);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateYulesQNetworkThreshold(fileProb,numTerms,threshold,parametersYulesQNetwork.getRelative());
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_Threshold_" + threshold + "_",dataOriginal,numClasses);
                }       
            }
            if(parametersYulesQNetwork.getNetworkTopK()){
                for(int topK=0;topK<parametersYulesQNetwork.getKs().size();topK++){
                    int k = parametersYulesQNetwork.getK(topK);
                    Neighbor[] adjacencyListTerms = TermNetworkGeneration.GenerateYulesQNetworkTopK(fileProb,numTerms,k);
                    learning(configuration,adjacencyListTerms,outputFile.toString(),outputFilePar.toString() + "_TopK_" + k + "_",dataOriginal,numClasses);
                }
            }
        }
        System.out.println("Process concluded successfully");
        configuration.getEmail().getContent().append(configuration.toString());
        configuration.getEmail().send();
    }
    
    //Function to set the parameters of semi-supervised inductive learning algorithms
    public static void learning(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration, Neighbor[] adjacencyListTerms, String output, String output2, Instances dataOriginal,int numClasses){
        for(int numEx=0;numEx<configuration.getParametersNumLabeledInstancesPerClass().getNumLabeledInstancesPerClass().size();numEx++){
            double numLabeledInstances = configuration.getParametersNumLabeledInstancesPerClass().getNumLabeledInstancesPerClass(numEx);
            StringBuilder outputFilePar = new StringBuilder();
            outputFilePar.append(numLabeledInstances);
            outputFilePar.append("_");
            if(configuration.isPorcentage() == true){
                outputFilePar.append("percentage");
                outputFilePar.append("_");
            }else{
                outputFilePar.append("real");
                outputFilePar.append("_");
            }
            if(configuration.isIMHN()){
                TCHN_DocTerm_TermTerm_InductiveSemiSupervised_ID classifIMHN = new TCHN_DocTerm_TermTerm_InductiveSemiSupervised_ID();
                StringBuilder outputFilePar2 = new StringBuilder();
                outputFilePar2.append(outputFilePar);
                outputFilePar2.append("TCHN_");
                classifIMHN.setAdjacencyListTerms(adjacencyListTerms);
                Parameters_IMHN parametersIMHN = configuration.getParameters_IMHN();
                for(int error=0;error<parametersIMHN.getErrors().size();error++){
                    for(int apr=0;apr<parametersIMHN.getErrorCorrectionRates().size();apr++){
                        System.out.println("Number of labeled intances per class: " + numLabeledInstances);
                        System.out.println("Classification Algorithm: TCHN Document-Document and Document-Term");
                        System.err.println("Minimum Mean Squared Error: " + parametersIMHN.getError(error));
                        System.out.println("Error Correction Rate: " + parametersIMHN.getErrorCorrectionRate(apr));
                        //classifIMHN.setUse(0);
                        classifIMHN.setErrorCorrectionRate(parametersIMHN.getErrorCorrectionRate(apr));
                        classifIMHN.setMinError(parametersIMHN.getError(error));
                        classifIMHN.setmaxNumberLocalIterations(parametersIMHN.getMaxNumberIterationsLocal());
                        classifIMHN.setmaxNumberGlobalIterations(parametersIMHN.getMaxNumberIterationsGlobal());
                        StringBuilder outputFilePar3 = new StringBuilder();
                        outputFilePar3.append(parametersIMHN.getErrorCorrectionRate(apr));
                        outputFilePar3.append("_");
                        outputFilePar3.append(parametersIMHN.getError(error));
                        outputFilePar3.append("_");
                        learning(configuration, classifIMHN, dataOriginal, output + outputFilePar2.toString() + output2 + outputFilePar3.toString(), (int)numLabeledInstances, numClasses);    
                    }
                }    
            }
            if(configuration.isLLGC()){
                StringBuilder outputFilePar2 = new StringBuilder();
                outputFilePar2.append(numLabeledInstances);
                outputFilePar2.append("_");
                if(configuration.isPorcentage() == true){
                    outputFilePar2.append("percentage");
                    outputFilePar2.append("_");
                }else{
                    outputFilePar2.append("real");
                    outputFilePar2.append("_");
                }
                TCTN_TermTerm_InductiveSemiSupervised classifTCTN = new TCTN_TermTerm_InductiveSemiSupervised();
                outputFilePar2.append("TCTN_");
                Parameters_LLGC parametersLLGC = configuration.getParameters_LLGC();
                for(int alpha=0;alpha<parametersLLGC.getAlphas().size();alpha++){
                    System.out.println("Number of labeled intances per class: " + numLabeledInstances);
                    System.out.println("Classification Algorithm: TCTN");
                    System.out.println("Alpha: " + parametersLLGC.getAlpha(alpha));
                    classifTCTN.setMaxNumIterations(parametersLLGC.getMaxNumberIterations());
                    classifTCTN.setAlpha(parametersLLGC.getAlpha(alpha));
                    classifTCTN.setAdjacencyListTerms(adjacencyListTerms);
                    StringBuilder outputFilePar3 = new StringBuilder();
                    outputFilePar3.append("_");
                    outputFilePar3.append(parametersLLGC.getAlpha(alpha));
                    classifTCTN.setUse(0);
                    learning(configuration, classifTCTN, dataOriginal, output + outputFilePar2.toString() + output2 + outputFilePar3.toString(), (int)numLabeledInstances, numClasses);
                }    
            }
            /*if(configuration.isLPHN()){
                //LPHN_DocTerm_TermTerm_Transductive classifLPHN = new LPHN_DocTerm_TermTerm_Transductive();
                LPHN_DocTerm_TermTerm_Transductive_ID classifLPHN = new LPHN_DocTerm_TermTerm_Transductive_ID();
                classifLPHN.setUse(0);
                StringBuilder outputFilePar2 = new StringBuilder();
                outputFilePar2.append(outputFilePar);
                outputFilePar2.append("LPHN_");
                classifLPHN.setAdjacencyListTerms(adjacencyListTerms);
                Parameters_LPHN parametersLPHN = configuration.getParameters_LPHN();
                System.out.println("Number of labeled intances per class: " + numLabeledInstances);
                System.out.println("Classification Algorithm: LPHNDDeTT");
                classifLPHN.setNumMaxIteration(parametersLPHN.getNumMaxIteration());
                learning(configuration, classifLPHN, dataOriginal, output + outputFilePar2.toString() + output2, numLabeledInstances, numClasses);    
            }
            if(configuration.isGNetMine()){
                //GNetMine_DocTerm_TermTerm_Transductive classifGNetMine = new GNetMine_DocTerm_TermTerm_Transductive();
                GNetMine_DocTerm_TermTerm_Transductive_ID classifGNetMine = new GNetMine_DocTerm_TermTerm_Transductive_ID();
                StringBuilder outputFilePar2 = new StringBuilder();
                outputFilePar2.append(outputFilePar);
                outputFilePar2.append("GNetMine_");
                Parameters_GNetMine_DocTerm_TermTerm parametersGNetMine = configuration.getParameters_GNetMine();
                for(int alpha=0;alpha<parametersGNetMine.getAlphasDocs().size();alpha++){
                    for(int lambda=0;lambda<parametersGNetMine.getLambdasDocTermo().size();lambda++){
                        System.out.println("Number of labeled intances per class: " + numLabeledInstances);
                        System.out.println("Classification Algorithm: GNetMineDTeTT");
                        System.out.println("Alpha Doc: " + parametersGNetMine.getAlphaDoc(alpha));
                        System.out.println("Lambda DocTermo: " + parametersGNetMine.getLambdaDocTermo(lambda));
                        classifGNetMine.setUse(0);
                        classifGNetMine.setNumMaxIteration(parametersGNetMine.getNumMaxIteration());
                        classifGNetMine.setAlphaDoc(parametersGNetMine.getAlphaDoc(alpha));
                        classifGNetMine.setLambdaDocTermo(parametersGNetMine.getLambdaDocTermo(lambda));
                        classifGNetMine.setAdjacencyListTerms(adjacencyListTerms);
                        StringBuilder outputFilePar3 = new StringBuilder();
                        outputFilePar3.append("_");
                        outputFilePar3.append(parametersGNetMine.getAlphaDoc(alpha));
                        outputFilePar3.append("_");
                        outputFilePar3.append(parametersGNetMine.getLambdaDocTermo(lambda));
                        learning(configuration, classifGNetMine, dataOriginal, output + outputFilePar2.toString() + output2 + outputFilePar3.toString(), numLabeledInstances, numClasses);    
                    }
                }    
            }*/
        }    
    }
    
    //Function to run and evaluate semi-supervised learning
    public static void learning(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration, InductiveSemiSupervisedClassifier classifier, Instances dataOriginal, String outputFile, int numInstPerClass, int numClasses){
        
        try{
            Integer[][] confusionMatrix = new Integer[numClasses][numClasses]; //matriz de confusão
            
            ArrayList<Double> accuracies = new ArrayList<Double>();
            ArrayList<Double> microPrecisions = new ArrayList<Double>();
            ArrayList<Double> microRecalls = new ArrayList<Double>();
            ArrayList<Double> macroPrecisions = new ArrayList<Double>();
            ArrayList<Double> macroRecalls = new ArrayList<Double>();
            ArrayList<Long> buildingTimes = new ArrayList<Long>(); 
            ArrayList<Long> classificationTimes = new ArrayList<Long>();
            
            int[] folds = new int[1];
            
            File output = new File(outputFile + "_" + configuration.getNumReps() + "_" + configuration.getNumFolds() + ".txt");
            if(output.exists()){
                CheckExperiment(configuration, output, accuracies, microPrecisions, microRecalls, macroPrecisions, macroRecalls, buildingTimes, classificationTimes, folds);
                if(accuracies.size() == (configuration.getNumReps() * configuration.getNumFolds())){
                    return;
                }
            }
            System.out.println("Output: " + output.getAbsolutePath());
            
            folds[0] = folds[0]-1;
            if(folds[0] < 0){
                folds[0] = 0;
            }
            
            Instances data = new Instances(dataOriginal);
            data.setClass(dataOriginal.attribute(dataOriginal.numAttributes()-1));
            data.randomize(new Random(0));
            for(int fold=folds[0]; fold<configuration.getNumFolds();fold++){
                System.out.println("Fold "+(fold+1));
                
                FileWriter resultFile = new FileWriter(output, true);
                resultFile.write("Fold: " + (fold + 1) + " --------------------------------------------------------------------\n");
                resultFile.close();
                
                int beginRep = 0;
                if(fold == 0){
                    beginRep = accuracies.size();
                }else{
                    beginRep = accuracies.size() % (fold * configuration.getNumReps());
                }
                
                for(int rep=beginRep;rep<configuration.getNumReps();rep++){
                    
                    for(int class1=0;class1<numClasses;class1++){
                        for(int class2=0;class2<numClasses;class2++){
                            confusionMatrix[class1][class2] = 0;
                        }
                    }
                    
                    System.out.println("Repetition: " + (rep + 1));
                    resultFile = new FileWriter(output, true);
                    resultFile.write("Repetition: " + (rep + 1) + " --------------------------------------------------------------------\n");
                    resultFile.close();

                    Instances dataTrain = data.trainCV(configuration.getNumFolds(), fold);
                    Instances dataTest = data.testCV(configuration.getNumFolds(),fold);

                    dataTrain.randomize(new Random(rep));
                    
                    Instances dataTrainLabeled = new Instances(dataTrain,0);
                    Instances dataTrainUnlabeled = new Instances(dataTrain,0);

                    SplitTrainTest(configuration, dataTrain, dataTrainLabeled, dataTrainUnlabeled, numInstPerClass);

                    long begin = System.currentTimeMillis();
                    classifier.buildClassifier(dataTrainLabeled,dataTrainUnlabeled);
                    long end  = System.currentTimeMillis();
                    buildingTimes.add(end - begin);

                    begin = System.currentTimeMillis();
                    Evaluations.SemiSupervisedInductiveEvaluation(classifier, dataTest, confusionMatrix);
                    end = System.currentTimeMillis();
                    classificationTimes.add(end - begin);

                    //Printing Confusion Matrix
                    for(int i1=0;i1<numClasses;i1++){
                        for(int i2=0;i2<numClasses;i2++){
                            System.out.print(confusionMatrix[i1][i2] + "\t");
                        }
                        System.out.println();
                    }
                    ComputeEvaluationMeasures(confusionMatrix, numClasses, accuracies, microPrecisions, microRecalls, macroPrecisions, macroRecalls);
                    SaveRepetition(configuration, output, accuracies.get((fold * configuration.getNumReps()) + rep), microPrecisions.get((fold * configuration.getNumReps()) + rep), microRecalls.get((fold * configuration.getNumReps()) + rep), macroPrecisions.get((fold * configuration.getNumReps()) + rep), macroRecalls.get((fold * configuration.getNumReps()) + rep), buildingTimes.get((fold * configuration.getNumReps()) + rep), classificationTimes.get((fold * configuration.getNumReps()) + rep), rep + 1);
                }
                    
            }    
            SaveAverage(configuration, output, accuracies, microPrecisions, microRecalls, macroPrecisions, macroRecalls, buildingTimes, classificationTimes);
            
        }catch(OutOfMemoryError e){
            configuration.getEmail().getContent().append("OutOfMemory!!!!");
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }catch(Exception e){
            System.err.println("Error when generating a classifier.");
            configuration.getEmail().getContent().append(e.getMessage());
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }
    }
    
    //Save the classification performance results from a repetition
    public static void SaveRepetition(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration, File file, double accuracy, double microPrecision, double microRecall, double macroPrecision, double macroRecall, long buildingTime, long classificationTime, int numRepetition){
        
        try{
            FileWriter outputResults = new FileWriter(file,true);
            
            outputResults.write("Accuracy (%): " + accuracy + "\n");
            outputResults.write("Error (%): " + (100 - accuracy) + "\n");
            outputResults.write("Micro-Precision: " + microPrecision + "\n");
            outputResults.write("Micro-Recall: " + microRecall + "\n");
            outputResults.write("Macro-Precision: " + macroPrecision + "\n");
            outputResults.write("Macro-Recall: " + macroRecall + "\n");
            outputResults.write("Model Building Time (s): " + ((double)buildingTime / (double)1000) + "\n");
            outputResults.write("Classification Time (s): " + ((double)classificationTime / (double)1000) + "\n");
            outputResults.write("Number of Iterations: " + 0 + "\n");
            outputResults.close();
        }catch(OutOfMemoryError e){
            configuration.getEmail().getContent().append("OutOfMemory!!!!");
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }catch(Exception e){
            System.err.println("Error when saving the results.");
            configuration.getEmail().getContent().append(e.getMessage());
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }
    }
    
    //Function to save the average of classification performance measures obtained from different repetitions
    public static void SaveAverage(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration, File file, ArrayList<Double> accuracies, ArrayList<Double> microPrecisions, ArrayList<Double> microRecalls, ArrayList<Double> macroPrecisions, ArrayList<Double> macroRecalls, ArrayList<Long> buildingTimes, ArrayList<Long> classificationTimes){
        System.out.println("Saving Results...");
        
        try{
            double acmAccuracy = 0;
            double acmMicroPrecision = 0;
            double acmMicroRecall = 0;
            double acmMacroPrecision = 0;
            double acmMacroRecall = 0;
            long acmBuildingTime = 0;
            long acmClassificationTime = 0;
            int acmiterations = 0;
            
            double acmSD = 0;
            
            FileWriter outputResults = new FileWriter(file,true);
            for(int fold=0; fold<configuration.getNumFolds();fold++){
                for(int rep=0;rep<configuration.getNumReps();rep++){
                    acmAccuracy += accuracies.get((fold * configuration.getNumReps()) + rep);
                    acmMicroPrecision += microPrecisions.get((fold * configuration.getNumReps()) + rep);
                    acmMicroRecall += microRecalls.get((fold * configuration.getNumReps()) + rep);
                    acmMacroPrecision += macroPrecisions.get((fold * configuration.getNumReps()) + rep);
                    acmMacroRecall += macroRecalls.get((fold * configuration.getNumReps()) + rep);
                    acmBuildingTime += buildingTimes.get((fold * configuration.getNumReps()) + rep);
                    acmClassificationTime += classificationTimes.get((fold * configuration.getNumReps()) + rep);
                }
            }

            outputResults.write("\n-------------------------------------\n");
                        
            double averageAccuracy = ((double)acmAccuracy / (double)(configuration.getNumReps() * configuration.getNumFolds()));
            double averageMicroPrecision = ((double)acmMicroPrecision / (double)(configuration.getNumReps() * configuration.getNumFolds()));
            double averageMicroRecall = ((double)acmMicroRecall / (double)(configuration.getNumReps() * configuration.getNumFolds()));
            double averageMacroPrecision = ((double)acmMacroPrecision / (double)(configuration.getNumReps() * configuration.getNumFolds()));
            double averageMacroRecall = ((double)acmMacroRecall / (double)(configuration.getNumReps() * configuration.getNumFolds()));
            
            //Standard Deviation of the Accuracy
            for(int rep=0;rep<configuration.getNumReps();rep++){
                for(int fold=0; fold<configuration.getNumFolds();fold++){
                    acmSD += Math.pow((accuracies.get((rep * configuration.getNumFolds()) + fold) - averageAccuracy), 2);
                }
            }
            acmSD = (double)acmSD / (double)(configuration.getNumReps() * configuration.getNumFolds());
            double desvio = Math.sqrt(acmSD);
            
            outputResults.write("Average Accuracy (%): " + averageAccuracy + "\n");
            outputResults.write("Average Micro-Precision: " + averageMicroPrecision + "\n");
            outputResults.write("Average Micro-Recall: " + averageMicroRecall + "\n");
            outputResults.write("Average Macro-Precision: " + averageMacroPrecision + "\n");
            outputResults.write("Average Macro-Recall: " + averageMacroRecall + "\n");
            outputResults.write("Standard Deviation Accuracy: " + desvio +"\n");
            outputResults.write("Average Model Building Time (s): " + (((double)acmBuildingTime / (double)1000) / (double)configuration.getNumReps())+"\n");
            outputResults.write("Average Classification Time (s): " + (((double)acmClassificationTime / (double)1000) / (double)configuration.getNumReps())+"\n");
            outputResults.write("Average Number of Iterations (s): " + ((double)acmiterations / (double)configuration.getNumReps()) + "\n");

            outputResults.close();
        }catch(OutOfMemoryError e){
            configuration.getEmail().getContent().append("OutOfMemory!!!!");
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }catch(Exception e){
            System.err.println("Error when saving the results.");
            configuration.getEmail().getContent().append(e.getMessage());
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }
    }
    
    //Function to recover experiments
    public static void CheckExperiment(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration, File file, ArrayList<Double> accuracies, ArrayList<Double> microPrecisions, ArrayList<Double> microRecalls, ArrayList<Double> macroPrecisions, ArrayList<Double> macroRecalls, ArrayList<Long> buildingTimes, ArrayList<Long> classificationTimes, int[] iniFold){
        try{
            BufferedReader arqResult = new BufferedReader(new FileReader(file));
            String line = "";
            int indRepetition = -1;
            double accuracy = -1;
            double microPrecision = -1;
            double microRecall = -1;
            double macroPrecision = -1;
            double macroRecall = -1;
            long buildingTime = -1;
            long classificationTime = -1;
            
            while((line = arqResult.readLine()) != null){
                if(line.contains("Average") || line.contains("Media")){
                    accuracies.add(accuracy);
                    microPrecisions.add(microPrecision);
                    microRecalls.add(microRecall);
                    macroPrecisions.add(macroPrecision);
                    macroRecalls.add(macroRecall);
                    buildingTimes.add(buildingTime);
                    classificationTimes.add(classificationTime);
                    return;
                }
                if(line.contains("Fold")){
                    String[] parts = line.split(" ");
                    iniFold[0] = Integer.parseInt(parts[1]);
                }
                if (line.contains("Repetition") || line.contains("Repetic")){
                    String[] parts = line.split(" ");
                    indRepetition = Integer.parseInt(parts[1]);
                    if((accuracy >= 0) && (microPrecision >= 0) && (microRecall >= 0) && (macroPrecision >= 0) && (macroRecall >= 0)){
                        accuracies.add(accuracy);
                        microPrecisions.add(microPrecision);
                        microRecalls.add(microRecall);
                        macroPrecisions.add(macroPrecision);
                        macroRecalls.add(macroRecall);
                        buildingTimes.add(buildingTime);
                        classificationTimes.add(classificationTime);
                    }
                    accuracy = -1;
                    microPrecision = -1;
                    microRecall = -1;
                    macroPrecision = -1;
                    macroRecall = -1;    
                    buildingTime = -1;
                    classificationTime = -1;
                }
                if((line.contains("Accuracy") || line.contains("Taxa de Acerto")) && (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        accuracy = Double.parseDouble(parts[1].trim());
                    }else{
                        accuracy = -1;
                    }
                }
                if((line.contains("Micro-Precision") || line.contains("Micro Precisao")) && (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        microPrecision = Double.parseDouble(parts[1].trim());
                    }else{
                        microPrecision = -1;
                    }
                }
                if((line.contains("Micro-Recall") || line.contains("Micro Revocacao")) && (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        microRecall = Double.parseDouble(parts[1].trim());
                    }else{
                        microRecall = -1;
                    }
                }
                if((line.contains("Macro-Precision") || line.contains("Macro Precisao")) && (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        macroPrecision = Double.parseDouble(parts[1].trim());
                    }else{
                        macroPrecision = -1;
                    }
                }
                if((line.contains("Macro-Recall") || line.contains("Macro Revocacao"))&& (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        macroRecall = Double.parseDouble(parts[1].trim());
                    }else{
                        macroRecall = -1;
                    }
                }
                if((line.contains("Model Building Time") || line.contains("Tempo Constru")) && (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        Double value = Double.parseDouble(parts[1].trim()) * 1000;
                        buildingTime = value.longValue();
                    }else{
                        buildingTime = -1;
                    }
                }
                if((line.contains("Classification Time") || line.contains("Tempo Classifi")) && (!line.contains("Average"))){
                    String[] parts = line.split(":");
                    if(parts.length == 2){
                        Double value = Double.parseDouble(parts[1].trim()) * 1000;
                        classificationTime = value.longValue();
                    }else{
                        classificationTime = -1;
                    }
                }
            }
        }catch(OutOfMemoryError e){
            configuration.getEmail().getContent().append("OutOfMemory!!!!");
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }catch(Exception e){
            System.err.println("Error when reading the results.");
            configuration.getEmail().getContent().append(e.getMessage());
            configuration.getEmail().getContent().append(configuration.toString());
            configuration.getEmail().send();
            e.printStackTrace();
            System.exit(0);
        }
    }
    
    /*Function to split text collection into labeled and unlabled sets. numInstPerClass instances for each class are selected as labeled examples.*/
    private static void SplitTrainTest(SemiSupervisedInductiveConfiguration_DocTermAndTermTermRelations configuration, Instances data, Instances dataTrain, Instances dataTest, double numInstPerClass){
        int numClasses = data.numClasses();
        int[] totalInstClass = new int[numClasses];
        int[] instPerClass = new int[numClasses];
        int[] instChosenByClass = new int[numClasses];
        for(int classe=0;classe<numClasses;classe++){
            totalInstClass[classe] = 0;
            instPerClass[classe] = 0;
            instChosenByClass[classe] = 0;
        }
        
        if(configuration.isPorcentage() == true){
            for(int inst=0;inst<data.numInstances();inst++){
                Instance instance = data.instance(inst);
                int classe = (int)instance.classValue();
                int value = totalInstClass[classe];
                value++;
                totalInstClass[classe] = value;
            }    
        }
        
        if(configuration.isPorcentage() == false){
            for(int classe=0;classe<numClasses;classe++){
                instPerClass[classe] = (int)numInstPerClass;
            }    
        }else{
            for(int classe=0;classe<numClasses;classe++){
                double value = totalInstClass[classe] * ((double)numInstPerClass/(double)100);
                if(value < 1){
                    value = 1;
                }
                instPerClass[classe] = (int)value;
            }
        }
        
        for(int inst=0;inst<data.numInstances();inst++){
            Instance instance = data.instance(inst);
            int classe = (int)instance.classValue();
            int value = instChosenByClass[classe];
            value++;
            if(value > instPerClass[classe]){
                dataTest.add(instance);
            }else{
                dataTrain.add(instance);
                instChosenByClass[classe] = value;
            }
        }
    }
    
    /*Function to compute Accuracy, Micro-Precision, Micro-Recall, Macro-Precision, and Macro-Recal */
    private static void ComputeEvaluationMeasures(Integer[][] confusionMatrix, int numClasses, ArrayList<Double> accuracies, ArrayList<Double> microPrecisions, ArrayList<Double> microRecalls, ArrayList<Double> macroPrecisions, ArrayList<Double> macroRecalls){
        int tp=0;
        int total=0;
        for(int i=0;i<numClasses;i++){
            for(int j=0;j<numClasses;j++){
                if(i==j){
                    tp += confusionMatrix[i][j];
                }
                total += confusionMatrix[i][j];
            }
        }
        double accuracy = ((double)tp/(double)total) * 100;
        accuracies.add(accuracy);
        
        double microPrecTotNum = 0, microPrecTotDen = 0, microRevTotNum = 0, microRevTotDen = 0, macroPrecTot = 0, macroRevTot = 0;
        for(int j=0;j<numClasses;j++){
            int TPi = confusionMatrix[j][j];
            int FPi = 0;
            for(int k=0;k<numClasses;k++){
                if(k!=j){
                    FPi += confusionMatrix[j][k];
                }
            }
            microPrecTotNum += TPi;
            microPrecTotDen += (TPi + FPi);
            if((TPi + FPi)==0){
                macroPrecTot += 0;
            }else{
                macroPrecTot += (double)TPi/(double)(TPi + FPi);
            }

            int FNi=0;
            for(int k=0;k<numClasses;k++){
                if(k!=j){
                    FNi += confusionMatrix[k][j];
                }
            }
            microRevTotNum += TPi;
            microRevTotDen += TPi + FNi;
            if((TPi + FNi)==0){
                macroRevTot += 0;
            }else{
                macroRevTot += (double)TPi/(double)(TPi + FNi);
            }
        }
        double microPrecision = (double)microPrecTotNum/(double)microPrecTotDen;
        double microRecall = (double)microRevTotNum/(double)microRevTotDen;
        double macroPrecision = (double) macroPrecTot / (double) numClasses;
        double macroRecall = (double)macroRevTot/(double)numClasses;
        microPrecisions.add(microPrecision);
        microRecalls.add(microRecall);
        macroPrecisions.add(macroPrecision);
        macroRecalls.add(macroRecall);
    }
}

//*****************************************************************************
// Author: Rafael Geraldeli Rossi
// E-mail: rgr.rossi at gmail com
// Last-Modified: January 29, 2015
// Description: This class implements function to geneate Exp and Mutual Knn
//              Networks considering Euclidean or Cosine as proximity measures.
//              The input of the functions (proximityFile) is a proximity file 
//              generated by TCTInterface.Interface_Utilities_
//              DocDocProximities.java
//*****************************************************************************  

package TCTNetworkGeneration;

import TCTStructures.IndexValue;
import TCTStructures.Neighbor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Random;

public class DocumentNetworkGeneration_ID {
    
    public static double[][] GenerateKnnNetworkCosineMatrix(File proximityFile, int valueK, int numInsts){
        double[][] matProx = new double [numInsts][];
        for(int inst=0;inst<numInsts;inst++){
            matProx[inst] = new double[inst + 1];
        }
        try{

            System.out.println("Reading Proximity file...");
            BufferedReader arqProx = new BufferedReader(new FileReader(proximityFile));
            String line = "";
            while((line = arqProx.readLine())!=null){
                String[] parts = line.split(",");
                if(parts.length == 3){
                    int id1 = Integer.parseInt(parts[0]);
                    int id2 = Integer.parseInt(parts[1]);
                    double prox = 0;
                    try{
                        prox = Double.parseDouble(parts[2]);
                    }catch(Exception e){ }
                    
                    if(id1 > id2){
                        matProx[id1][id2] = prox;
                    }else{
                        matProx[id2][id1] = prox;
                    }
                }
            }
            arqProx.close();
            for(int inst1=0;inst1<numInsts;inst1++){
                matProx[inst1][inst1] = -1;
            }
            
            int[][] kNeighbors = new int[numInsts][valueK];
            double[][] kProximities = new double[numInsts][valueK];
            for(int inst1=0;inst1<numInsts;inst1++){
                ArrayList<Integer> indexsEscolhidos = new ArrayList<Integer>();
                for(int pos=0;pos<valueK;pos++){
                    int ind = -1;
                    double maior = Double.MIN_VALUE;
                    for(int inst2=0;inst2<numInsts;inst2++){
                        if(indexsEscolhidos.contains(inst2)){
                            continue;
                        }
                        if(inst1 > inst2){
                            if(matProx[inst1][inst2] > maior){
                                ind = inst2;
                                maior = matProx[inst1][inst2];
                            }    
                        }else{
                            if(matProx[inst2][inst1] > maior){
                                ind = inst2;
                                maior = matProx[inst2][inst1];
                            }
                        }
                        
                    }
                    kNeighbors[inst1][pos] = ind;
                    kProximities[inst1][pos] = maior;
                    if(ind != -1){
                        indexsEscolhidos.add(ind);
                    }
                }
            }
            
            for(int inst=0;inst<numInsts;inst++){
                matProx[inst] = new double[inst + 1];
            }
            double sigma = 0;
            for(int inst1=0;inst1<numInsts;inst1++){
                sigma += 1 - kProximities[inst1][valueK-1];
            }
            sigma = (double)sigma / (double)(3 * (numInsts));
            
            for(int inst1=0;inst1<numInsts;inst1++){
                matProx[inst1] = new double[inst1 + 1];
            }
            for(int inst1=0;inst1<numInsts;inst1++){
                for(int pos1=0;pos1<valueK;pos1++){
                    boolean flag = false;
                    int ind = kNeighbors[inst1][pos1];
                    if(ind == -1){
                        continue;
                    }
                    for(int pos2=0;pos2<valueK;pos2++){
                        if(kNeighbors[ind][pos2] == inst1){
                            flag = true;
                            if(inst1 > ind){
                                matProx[inst1][ind] = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][pos1]), 2)) / (2 * Math.pow(sigma, 2)));
                            }else{
                                matProx[ind][inst1] = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][pos1]), 2)) / (2 * Math.pow(sigma, 2)));
                            }
                            break;
                        }
                    }
                    if(flag == false){
                        if(kNeighbors[inst1][0] != -1){
                            if(inst1 > kNeighbors[inst1][0]){
                                matProx[inst1][kNeighbors[inst1][0]] = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][0]), 2)) / (2 * Math.pow(sigma, 2)));
                            }else{
                                matProx[kNeighbors[inst1][0]][inst1] = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][0]), 2)) / (2 * Math.pow(sigma, 2)));
                            }
                        }else{
                            int randomNumber = (int)(new Random().nextDouble() * numInsts);
                            if(inst1 > randomNumber){
                                matProx[inst1][randomNumber] = Math.exp(((-1) * Math.pow((1 - 0.01), 2)) / (2 * Math.pow(sigma, 2)));
                            }else{
                                matProx[randomNumber][inst1] = Math.exp(((-1) * Math.pow((1 - 0.01), 2)) / (2 * Math.pow(sigma, 2)));
                            }
                        }
                    }
                }
                    
            }
        }catch(Exception e){
            System.out.println("Error when reading proximity file.");
            e.printStackTrace();
            System.exit(0);
        }
        return matProx;
    }
    
    public static Neighbor[] GenerateKnnNetworkCosineAdjList(File proximityFile, int valueK, int numInsts){
        Neighbor[] adjList = new Neighbor[numInsts];
        for(int inst=0;inst<numInsts;inst++){
            adjList[inst] = new Neighbor();
        }
        
        try{
            System.out.println("Reading Proximity file...");
            BufferedReader arqProx = new BufferedReader(new FileReader(proximityFile));
            String line = "";
            while((line = arqProx.readLine())!=null){
                String[] parts = line.split(",");
                if(parts.length == 3){
                    int id1 = Integer.parseInt(parts[0]);
                    int id2 = Integer.parseInt(parts[1]);
                    double prox = 0;
                    try{
                        prox = Double.parseDouble(parts[2]);
                    }catch(Exception e){ }
                    
                    IndexValue indVal = new IndexValue();
                    indVal.setIndex(id2);
                    indVal.setValue(prox);
                    adjList[id1].AddNeighbor(indVal);
                    indVal = new IndexValue();
                    indVal.setIndex(id1);
                    indVal.setValue(prox);
                    adjList[id2].AddNeighbor(indVal);
                }
            }
            arqProx.close();
            
            Long begin = System.currentTimeMillis();
            int[][] kNeighbors = new int[numInsts][valueK];
            double[][] kProximities = new double[numInsts][valueK];
            for(int inst1=0;inst1<numInsts;inst1++){
                ArrayList<Integer> indexsEscolhidos = new ArrayList<Integer>();
                for(int pos=0;pos<valueK;pos++){
                    int ind = -1;
                    double maior = Double.MIN_VALUE;
                    ArrayList<IndexValue> neighbors = adjList[inst1].getNeighbors();
                    for(int inst2=0;inst2<neighbors.size();inst2++){
                        if(indexsEscolhidos.contains(neighbors.get(inst2).getIndex())){
                            continue;
                        }
                        if(neighbors.get(inst2).getValue() > maior){
                            ind = neighbors.get(inst2).getIndex();
                            maior = neighbors.get(inst2).getValue();
                        }
                        
                    }
                    kNeighbors[inst1][pos] = ind;
                    kProximities[inst1][pos] = maior;
                    if(ind != -1){
                        indexsEscolhidos.add(ind);
                    }
                    
                }
            }
            

            double sigma = 0;
            for(int inst1=0;inst1<numInsts;inst1++){
                sigma += 1 - kProximities[inst1][valueK-1];
            }
            sigma = (double)sigma / (double)(3 * (numInsts));
            
            for(int inst=0;inst<numInsts;inst++){
                adjList[inst] = new Neighbor();
            }
            
            for(int inst1=0;inst1<numInsts;inst1++){
                boolean flag = false;
                for(int pos1=0;pos1<valueK;pos1++){
                    int ind = kNeighbors[inst1][pos1];
                    if(ind == -1){
                        continue;
                    }
                    for(int pos2=0;pos2<valueK;pos2++){
                        if(kNeighbors[ind][pos2] == inst1){
                            flag = true;
                            double prox = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][pos1]), 2)) / (2 * Math.pow(sigma, 2)));
                            IndexValue indVal = new IndexValue();
                            indVal.setIndex(ind);
                            indVal.setValue(prox);
                            adjList[inst1].AddNeighbor(indVal);
                            break;
                        }
                    }
   
                }
                if(flag == false){
                    if(kNeighbors[inst1][0] != -1){
                        double prox = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][0]), 2)) / (2 * Math.pow(sigma, 2)));
                        IndexValue indVal = new IndexValue();
                        indVal.setIndex(kNeighbors[inst1][0]);
                        indVal.setValue(prox);
                        adjList[inst1].AddNeighbor(indVal);
                        indVal = new IndexValue();
                        indVal.setIndex(inst1);
                        indVal.setValue(prox);
                        adjList[kNeighbors[inst1][0]].AddNeighbor(indVal);
                    }else{
                        int randomNumber = (int)(new Random().nextDouble() * numInsts);
                        double prox = Math.exp(((-1) * Math.pow((1 - 0.01), 2)) / (2 * Math.pow(sigma, 2)));
                        IndexValue indVal = new IndexValue();
                        indVal.setIndex(randomNumber);
                        indVal.setValue(prox);
                        adjList[inst1].AddNeighbor(indVal);
                        indVal = new IndexValue();
                        indVal.setIndex(inst1);
                        indVal.setValue(prox);
                        adjList[randomNumber].AddNeighbor(indVal);
                    }
                }
            }
            Long end = System.currentTimeMillis();
            System.out.println("Time to build document network: " + ((end - begin)/1000) + " seconds");
        }catch(Exception e){
            System.out.println("Error when reading proximity file.");
            e.printStackTrace();
            System.exit(0);
        }
        return adjList;
    }
    
    public static Neighbor[] GenerateKnnNetworkEuclideanList(File proximityFile, int valueK, int numInsts){
        Neighbor[] adjList = new Neighbor[numInsts];
        for(int inst=0;inst<numInsts;inst++){
            adjList[inst] = new Neighbor();
        }
        
        try{
            System.out.println("Reading Proximity file...");
            BufferedReader arqProx = new BufferedReader(new FileReader(proximityFile));
            String line = "";
            while((line = arqProx.readLine())!=null){
                String[] parts = line.split(",");
                if(parts.length == 3){
                    int id1 = Integer.parseInt(parts[0]);
                    int id2 = Integer.parseInt(parts[1]);
                    double prox = 0;
                    try{
                        prox = Double.parseDouble(parts[2]);
                    }catch(Exception e){ }
                    
                    IndexValue indVal = new IndexValue();
                    indVal.setIndex(id2);
                    indVal.setValue(prox);
                    adjList[id1].AddNeighbor(indVal);
                    indVal = new IndexValue();
                    indVal.setIndex(id1);
                    indVal.setValue(prox);
                    adjList[id2].AddNeighbor(indVal);
                }
            }
            arqProx.close();
            
            System.out.println("Generating Doc-Doc Relations...");
            
            int[][] kNeighbors = new int[numInsts][valueK];
            double[][] kProximities = new double[numInsts][valueK];
            for(int inst1=0;inst1<numInsts;inst1++){
                ArrayList<Integer> indexsEscolhidos = new ArrayList<Integer>();
                for(int pos=0;pos<valueK;pos++){
                    int ind = -1;
                    double min = Double.MAX_VALUE;
                    ArrayList<IndexValue> neighbors = adjList[inst1].getNeighbors();
                    for(int inst2=0;inst2<neighbors.size();inst2++){
                        if(indexsEscolhidos.contains(neighbors.get(inst2).getIndex())){
                            continue;
                        }
                        if(neighbors.get(inst2).getValue() < min){
                            ind = neighbors.get(inst2).getIndex();
                            min = neighbors.get(inst2).getValue();
                        }
                        
                    }
                    kNeighbors[inst1][pos] = ind;
                    kProximities[inst1][pos] = min;
                    if(ind != -1){
                        indexsEscolhidos.add(ind);
                    }
                    
                }
            }
            

            double sigma = 0;
            for(int inst1=0;inst1<numInsts;inst1++){
                sigma += 1 - kProximities[inst1][valueK-1];
            }
            sigma = (double)sigma / (double)(3 * (numInsts));
            
            for(int inst=0;inst<numInsts;inst++){
                adjList[inst] = new Neighbor();
            }
            
            for(int inst1=0;inst1<numInsts;inst1++){
                boolean flag = false;
                for(int pos1=0;pos1<valueK;pos1++){
                    int ind = kNeighbors[inst1][pos1];
                    if(ind == -1){
                        continue;
                    }
                    for(int pos2=0;pos2<valueK;pos2++){
                        if(kNeighbors[ind][pos2] == inst1){
                            flag = true;
                            double prox = Math.exp(((-1) * Math.pow((kProximities[inst1][pos1]), 2)) / (2 * Math.pow(sigma, 2)));
                            IndexValue indVal = new IndexValue();
                            indVal.setIndex(ind);
                            indVal.setValue(prox);
                            adjList[inst1].AddNeighbor(indVal);
                            break;
                        }
                    }
   
                }
                if(flag == false){
                    if(kNeighbors[inst1][0] != -1){
                        double prox = Math.exp(((-1) * Math.pow((kProximities[inst1][0]), 2)) / (2 * Math.pow(sigma, 2)));
                        IndexValue indVal = new IndexValue();
                        indVal.setIndex(kNeighbors[inst1][0]);
                        indVal.setValue(prox);
                        adjList[inst1].AddNeighbor(indVal);
                        indVal = new IndexValue();
                        indVal.setIndex(inst1);
                        indVal.setValue(prox);
                        adjList[kNeighbors[inst1][0]].AddNeighbor(indVal);
                    }else{
                        int randomNumber = (int)(new Random().nextDouble() * numInsts);
                        double prox = Math.exp(((-1) * Math.pow((1 - 0.01), 2)) / (2 * Math.pow(sigma, 2)));
                        IndexValue indVal = new IndexValue();
                        indVal.setIndex(randomNumber);
                        indVal.setValue(prox);
                        adjList[inst1].AddNeighbor(indVal);
                        indVal = new IndexValue();
                        indVal.setIndex(inst1);
                        indVal.setValue(prox);
                        adjList[randomNumber].AddNeighbor(indVal);
                    }
                }
            }
        }catch(Exception e){
            System.out.println("Error when reading proximity file.");
            e.printStackTrace();
            System.exit(0);
        }
        return adjList;
    }
    
    public static double[][] GenerateKnnNetworkEuclideanMatrix(File proximityFile, int valueK, int numInsts){
        double[][] matProx = new double [numInsts][];
        for(int inst=0;inst<numInsts;inst++){
            matProx[inst] = new double[inst + 1];
        }
        
        try{
            System.out.println("Reading Proximity file...");
            BufferedReader arqProx = new BufferedReader(new FileReader(proximityFile));
            String line = "";
            while((line = arqProx.readLine())!=null){
                String[] parts = line.split(",");
                if(parts.length == 3){
                    int id1 = Integer.parseInt(parts[0]);
                    int id2 = Integer.parseInt(parts[1]);
                    double prox = 0;
                    try{
                        prox = Double.parseDouble(parts[2]);
                    }catch(Exception e){}
                    if(id1 > id2){
                        matProx[id1][id2] = prox;
                    }else{
                        matProx[id2][id1] = prox;
                    }
                }
            }
            arqProx.close();
            for(int inst1=0;inst1<numInsts;inst1++){
                matProx[inst1][inst1] = Double.MAX_VALUE;
            }
            
            System.out.println("Generating Doc-Doc Relations...");
            
            int[][] kNeighbors = new int[numInsts][valueK];
            double[][] kProximities = new double[numInsts][valueK];
            for(int inst1=0;inst1<numInsts;inst1++){
                ArrayList<Integer> indexsEscolhidos = new ArrayList<Integer>();
                for(int pos=0;pos<valueK;pos++){
                    int ind = -1;
                    double min = Double.MAX_VALUE;
                    for(int inst2=0;inst2<numInsts;inst2++){
                        if(inst1 > inst2){
                            if(matProx[inst1][inst2] < min){
                                ind = inst2;
                                min = matProx[inst1][inst2];
                            }    
                        }else{
                            if(matProx[inst2][inst1] < min){
                                ind = inst2;
                                min = matProx[inst2][inst1];
                            }
                        }
                        
                    }
                    kNeighbors[inst1][pos] = ind;
                    kProximities[inst1][pos] = min;
                    if(ind != -1){
                        indexsEscolhidos.add(ind);
                    }
                }
            }
            
            for(int inst=0;inst<numInsts;inst++){
                matProx[inst] = new double[inst + 1];
            }
            double sigma = 0;
            for(int inst1=0;inst1<numInsts;inst1++){
                sigma += 1 - kProximities[inst1][valueK-1];
            }
            sigma = (double)sigma / (double)(3 * (numInsts));
            for(int inst1=0;inst1<numInsts;inst1++){
                for(int pos=0;pos<valueK;pos++){
                    if(kNeighbors[inst1][pos] != -1){
                        if(inst1 > kNeighbors[inst1][pos]){
                            matProx[inst1][kNeighbors[inst1][pos]] = Math.exp(((-1) * Math.pow((kProximities[inst1][pos]), 2)) / (2 * Math.pow(sigma, 2)));
                        }else{
                            matProx[kNeighbors[inst1][pos]][inst1] = Math.exp(((-1) * Math.pow((kProximities[inst1][pos]), 2)) / (2 * Math.pow(sigma, 2)));
                        }
                    }
                }
            }
            
            for(int inst1=0;inst1<numInsts;inst1++){
                boolean flag = false;
                for(int pos1=0;pos1<valueK;pos1++){
                    int ind = kNeighbors[inst1][pos1];
                    for(int pos2=0;pos2<valueK;pos2++){
                        if(kNeighbors[ind][pos2] == inst1){
                            flag = true;
                            if(inst1 > ind){
                                matProx[inst1][ind] = Math.exp(((-1) * Math.pow((kProximities[inst1][pos1]), 2)) / (2 * Math.pow(sigma, 2)));
                            }else{
                                matProx[ind][inst1] = Math.exp(((-1) * Math.pow((kProximities[inst1][pos1]), 2)) / (2 * Math.pow(sigma, 2)));
                            }
                            break;
                        }
                    }
                }
                if(flag == false){
                    if(kNeighbors[inst1][0] != -1){
                        if(inst1 > kNeighbors[inst1][0]){
                            matProx[inst1][kNeighbors[inst1][0]] = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][0]), 2)) / (2 * Math.pow(sigma, 2)));
                        }else{
                            matProx[kNeighbors[inst1][0]][inst1] = Math.exp(((-1) * Math.pow((1 - kProximities[inst1][0]), 2)) / (2 * Math.pow(sigma, 2)));
                        }
                    }else{
                        int randomNumber = (int)(new Random().nextDouble() * numInsts);
                        if(inst1 > randomNumber){
                            matProx[inst1][randomNumber] = Math.exp(((-1) * Math.pow((1 - 0.01), 2)) / (2 * Math.pow(sigma, 2)));
                        }else{
                            matProx[randomNumber][inst1] = Math.exp(((-1) * Math.pow((1 - 0.01), 2)) / (2 * Math.pow(sigma, 2)));
                        }
                    }
                }
                    
            }
        }catch(Exception e){
            System.out.println("Error when reading proximity file.");
            e.printStackTrace();
            System.exit(0);
        }
        return matProx;
    }
    
    public static Neighbor[] GenerateExpNetworkAdjacencyList(File proximityFile, double valueSigma, int numInsts, boolean cosine){
        Neighbor[] adjList = new Neighbor[numInsts];
        for(int inst=0;inst<numInsts;inst++){
            adjList[inst] = new Neighbor();
        }
        
        try{
            System.out.println("Reading Proximity File and Generating Doc-Doc Relations...");
            BufferedReader arqProx = new BufferedReader(new FileReader(proximityFile));
            String line = "";
            Long totalTime = 0L;
            while((line = arqProx.readLine())!=null){
                String[] parts = line.split(",");
                if(parts.length == 3){
                    int id1 = Integer.parseInt(parts[0]);
                    int id2 = Integer.parseInt(parts[1]);
                    double prox = 0;
                    try{
                        prox = Double.parseDouble(parts[2]);
                    }catch(Exception e){ }
                    
                    if(cosine){
                        prox = 1 - prox;
                    }
                    Long begin = System.currentTimeMillis();
                    double value = Math.exp(((-1) * prox) / (2 * Math.pow(valueSigma, 2)));
                    IndexValue indVal = new IndexValue();
                    indVal.setIndex(id2);
                    indVal.setValue(value);
                    adjList[id1].AddNeighbor(indVal);
                    indVal = new IndexValue();
                    indVal.setIndex(id1);
                    indVal.setValue(value);
                    adjList[id2].AddNeighbor(indVal);
                    Long end = System.currentTimeMillis();
                    totalTime = (end - begin);
                }
            }
            arqProx.close();
            System.out.println("Time to build document networks: " + (totalTime/1000) + " seconds");
                    
        }catch(Exception e){
            System.out.println("Error when reading proximity file.");
            e.printStackTrace();
            System.exit(0);
        }
        
        return adjList;
    }
    
    public static double[][] GenerateGaussianNetworkMatrix(File proximityFile, double valueSigma, int numInsts, boolean cosine){
        double[][] matProx = new double [numInsts][];
        for(int inst=0;inst<numInsts;inst++){
            matProx[inst] = new double[inst + 1];
        }
        try{
            System.out.println("Reading Proximity file and Generating Doc-Doc Relations...");
            BufferedReader arqProx = new BufferedReader(new FileReader(proximityFile));
            String line = "";
            while((line = arqProx.readLine())!=null){
                String[] parts = line.split(",");
                if(parts.length == 3){
                    int id1 = Integer.parseInt(parts[0]);
                    int id2 = Integer.parseInt(parts[1]);
                    double prox = 0;
                    try{
                        prox = Double.parseDouble(parts[2]);
                    }catch(Exception e){ }
                    
                    if(cosine){
                        prox = 1 - prox;
                    }
                    if(id1 > id2){
                        matProx[id1][id2] = Math.exp(((-1) * prox) / (2 * Math.pow(valueSigma, 2)));
                    }else{
                        matProx[id2][id1] = Math.exp(((-1) * prox) / (2 * Math.pow(valueSigma, 2)));
                    }

                }
            }
            arqProx.close();
        }catch(Exception e){
            System.out.println("Error when reading proximity file.");
            e.printStackTrace();
            System.exit(0);
        }
        return matProx;
    }
    
}

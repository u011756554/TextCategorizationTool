//*****************************************************************************
// Author: Rafael Geraldeli Rossi
// E-mail: rgr.rossi at gmail com
// Last-Modified: January 29, 2015
// Description: Class to generate relations among terms as described in
//              Rossi et al., 2015. The variable arqIn (used as input in the 
//              functions) is a path of a file containing the propabability of
//              the terms occur and co-occur with other terms. This file is
//              generated by the class TCTInterfaces.Interface_Utilities_
//              TermTermProbabilities.java.
// References: - R. G. Rossi, S. O. Rezende, A. A. Lopes, Term Network Approach 
//               for Transductive Classification, in: International Conference 
//               on Intelligent Text Processing and Computational Linguistics, 
//               2015 (in press).
//*****************************************************************************  

package TCTNetworkGeneration;

import TCTStructures.IndexValue;
import TCTStructures.Neighbor;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;

public class TermNetworkGeneration {
    
    // Funtion to generate term-term relations considering Support as similarity measure and threshold aprroach
    public static Neighbor[] GenerateSupportNetworkThreshold(File arqIn, int numTerms, double threshold, boolean relative){
        System.out.println("Loading probability file...");
        System.out.println("Support - Threshold");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double probs[] = new double[numTerms];
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                        
                        if(probAB > max){
                            max = probAB;
                        }
                        if(probAB < min){
                            min = probAB;
                        }
                    }catch(Exception e){ }
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = probAB;
                    adjacencyListTerms[keyA].AddNeighbor(indVal1);
                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = probAB;
                    adjacencyListTerms[keyB].AddNeighbor(indVal2);
                }
            }
            if(relative == true){
                threshold = ((max - min) * threshold) + min;
            }
            for(int term=0;term<numTerms;term++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term].getNeighbors();
                for(int neighbor=0;neighbor<neighbors.size();neighbor++){
                    if(neighbors.get(neighbor).value < threshold){
                        neighbors.remove(neighbor);
                        neighbor--;
                    }
                }
            }
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }
        System.out.println("Max Support: " + max);
        System.out.println("Min Suporte: " + min);
        System.out.println("Term-term relations were generated.");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Support as similarity measure and TopK aprroach
    public static Neighbor[] GenerateSupportNetworkTopK(File arqIn, int numTerms, int k){
        System.out.println("Loading probability file...");
        System.out.println("Support-TopK");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        double probs[] = new double[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = probAB;
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[keyA].getNeighbors();
                    if(neighbors.size()== 0){
                        neighbors.add(indVal1);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(probAB == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(probAB<neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                flag = true;
                                break;
                            }
                        }
                        if(equal == false){
                            if(flag == false){
                                neighbors.add(indVal1);
                            }
                        }
                        
                    }

                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = probAB;
                    neighbors = adjacencyListTerms[keyB].getNeighbors();
                    if(neighbors.size()==0){
                        neighbors.add(indVal2);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(probAB == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(probAB<neighbors.get(pos).value){
                                neighbors.add(pos,indVal2);
                                flag = true;
                                break;
                            }
                        }
                    }
                }
            }
        
            IndexValue[] maxima = new IndexValue[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                IndexValue indVal = new IndexValue();
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo].getNeighbors();
                if(neighbors.size() != 0){
                    indVal = neighbors.get(neighbors.size() - 1);
                    maxima[termo] = indVal;
                }            
            }

            ArrayList<Double>[] topKvalues = new ArrayList[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                topKvalues[termo] = new ArrayList<Double>();
            }
            for(int termo1=0;termo1<numTerms;termo1++){
                int count = 0;
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo1].getNeighbors();
                for(int termo2=neighbors.size()-1;termo2>=0;termo2--){
                    IndexValue indVal = neighbors.get(termo2);
                    if(!topKvalues[termo1].contains(indVal.value)){
                        topKvalues[termo1].add(indVal.value);
                        count++;
                        if(count>=k){
                            break;
                        }
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                for(int term2=0;term2<neighbors.size();term2++){
                    IndexValue indVal = neighbors.get(term2);
                    if(!topKvalues[term1].contains(indVal.value)){
                        neighbors.remove(0);
                        term2--;
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<Double> topKvaluesT1 = topKvalues[term1];
                for(int valueT1=0;valueT1<topKvaluesT1.size();valueT1++){
                   double topKT1 = topKvaluesT1.get(valueT1);
                    ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighborsT1.size();term2++){
                        IndexValue indVal = neighborsT1.get(term2);
                        ArrayList<Double> topKvaluesT2 = topKvalues[indVal.index];
                        if(!topKvaluesT2.contains(topKT1)){
                            neighborsT1.remove(term2);
                            term2--;
                        }
                    }    
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                if(neighborsT1.size() == 1){
                    if(neighborsT1.get(0) == null){
                        neighborsT1.remove(0);
                    }
                }
                if(neighborsT1.size() == 0){
                    if(maxima[term1] != null){
                        neighborsT1.add(maxima[term1]);
                    }
                }
            }
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }
        System.out.println("Term-term relations were generated.");
        
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Yule's Q as similarity measure and threshold aprroach
    public static Neighbor[] GenerateYulesQNetworkThreshold(File arqIn, int numTerms, double threshold, boolean relative){
        System.out.println("Loading probability file...");
        System.out.println("Yule's Q");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double probs[] = new double[numTerms];
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    double probA = probs[keyA];
                    double probB = probs[keyB];
                    double numerator =   (probAB * (1 - probA - probB + probAB)) - ((probA - probAB) * (probB - probAB)); 
                    double denominator = (probAB * (1 - probA - probB + probAB)) + ((probA - probAB) * (probB - probAB)); 

                    Double qYule = 0.0;
                    if(denominator!=0){
                        qYule = numerator / denominator;
                    }
                    
                    if(qYule <= 0){
                        continue;
                    }
                    
                    if(qYule < min){
                        min = qYule;
                    }
                    if(qYule > max){
                        max = qYule;
                    }
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = qYule;
                    adjacencyListTerms[keyA].AddNeighbor(indVal1);
                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = qYule;
                    adjacencyListTerms[keyB].AddNeighbor(indVal2);
                }
            }
            
            System.out.println("Max Yule's Q: " + max);
            System.out.println("Min Yule's Q: " + min);
                        
            
            
            if(relative == true){
                threshold = ((max - min) * threshold) + min;
            }
            for(int term=0;term<numTerms;term++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term].getNeighbors();
                for(int neighbor=0;neighbor<neighbors.size();neighbor++){
                    if(neighbors.get(neighbor).value < threshold){
                        neighbors.remove(neighbor);
                        neighbor--;
                    }
                }
            }
            
            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null){ continue; }
                        neighbors.get(term2).value += min;
                    }
                }
            }
            
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }

        System.out.println("Term-term relations were generated.");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Yule's Q as similarity measure and TopK aprroach
    public static Neighbor[] GenerateYulesQNetworkTopK(File arqIn, int numTerms, int k){
        System.out.println("Loading probability file...");
        System.out.println("Yule's Q - TopK");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        double probs[] = new double[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
        
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }                    
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    
                    double numerator =   (probAB * (1 - probs[keyA] - probs[keyB] + probAB)) - ((probs[keyA] - probAB) * (probs[keyB] - probAB)); 
                    double denominator = (probAB * (1 - probs[keyA] - probs[keyB] + probAB)) + ((probs[keyA] - probAB) * (probs[keyB] - probAB)); 

                    Double qYule = 0.0;
                    if(denominator!=0){
                        qYule = numerator / denominator;
                    }

                    if(qYule < min){
                        min = qYule;
                    }
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = qYule;
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[keyA].getNeighbors();
                    if(neighbors.size()== 0){
                        neighbors.add(indVal1);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(qYule == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(qYule<neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                flag = true;
                                break;
                            }
                        }
                        if(equal == false){
                            if(flag == false){
                                neighbors.add(indVal1);
                            }
                        }
                        
                    }

                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = qYule;
                    neighbors = adjacencyListTerms[keyB].getNeighbors();
                    if(neighbors.size()==0){
                        neighbors.add(indVal2);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(qYule == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(qYule<neighbors.get(pos).value){
                                neighbors.add(pos,indVal2);
                                flag = true;
                                break;
                            }
                        }
                    }
                }
            }
                
            IndexValue[] maxima = new IndexValue[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                IndexValue indVal = new IndexValue();
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo].getNeighbors();
                if(neighbors.size() != 0){
                    indVal = neighbors.get(neighbors.size() - 1);
                    maxima[termo] = indVal;
                }
            }

            ArrayList<Double>[] topKvalues = new ArrayList[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                topKvalues[termo] = new ArrayList<Double>();
            }
            for(int termo1=0;termo1<numTerms;termo1++){
                int count = 0;
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo1].getNeighbors();
                for(int termo2=neighbors.size()-1;termo2>=0;termo2--){
                    IndexValue indVal = neighbors.get(termo2);
                    if(!topKvalues[termo1].contains(indVal.value)){
                        topKvalues[termo1].add(indVal.value);
                        count++;
                        if(count>=k){
                            break;
                        }
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                for(int term2=0;term2<neighbors.size();term2++){
                    IndexValue indVal = neighbors.get(term2);
                    if(!topKvalues[term1].contains(indVal.value)){
                        neighbors.remove(0);
                        term2--;
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<Double> topKvaluesT1 = topKvalues[term1];
                for(int valueT1=0;valueT1<topKvaluesT1.size();valueT1++){
                   double topKT1 = topKvaluesT1.get(valueT1);
                    ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighborsT1.size();term2++){
                        IndexValue indVal = neighborsT1.get(term2);
                        ArrayList<Double> topKvaluesT2 = topKvalues[indVal.index];
                        if(!topKvaluesT2.contains(topKT1)){
                            neighborsT1.remove(term2);
                            term2--;
                        }
                    }    
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                if(neighborsT1.size() == 1){
                    if(neighborsT1.get(0) == null){
                        neighborsT1.remove(0);
                    }
                }
                if(neighborsT1.size() == 0){
                    if(maxima[term1] != null){
                        neighborsT1.add(maxima[term1]);
                    }
                }
            }

            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null){ continue; }
                        neighbors.get(term2).value += min;
                    }
                }
            }
            
            
            
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }

        
        System.out.println("Term-term relations were generated.");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Mutual Information as similarity measure and Threshold aprroach
    public static Neighbor[] GenerateMutualInformationNetworkThreshold(File arqIn, int numTerms, double threshold, boolean relative){
        System.out.println("Loading probability file...");
        System.out.println("Mutual Information - Threshold");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];;
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        
        double probs[] = new double[numTerms];
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    double probA = probs[keyA];
                    double probB = probs[keyB];

                    Double mutualInf1 = mutualInf1 = probAB * (Math.log10(probAB/(probA * probB))/0.301);
                    if(mutualInf1.isNaN()){
                        mutualInf1 = 0.0;
                    }
                    if(mutualInf1.isInfinite()){
                        mutualInf1 = 0.0;
                    }
                    Double mutualInf2 = mutualInf2 = (probA - probAB) * (Math.log10((probA - probAB)/(probA*(1-probB)))/0.301);
                    if(mutualInf2.isNaN()){
                        mutualInf2 = 0.0;
                    }
                    if(mutualInf2.isInfinite()){
                        mutualInf2 = 0.0;
                    }
                    Double mutualInf3 = (probB - probAB) * (Math.log10((probB - probAB)/((1-probA)*probB))/0.301);
                    if(mutualInf3.isNaN()){
                        mutualInf3 = 0.0;
                    }
                    if(mutualInf3.isInfinite()){
                        mutualInf3 = 0.0;
                    }
                    Double mutualInf4 = (1 - probA - probB + probAB) * (Math.log10((1 - probA - probB + probAB)/((1-probA)*(1-probB)))/0.301);;
                    if(mutualInf4.isNaN()){
                        mutualInf4 = 0.0;
                    }
                    if(mutualInf4.isInfinite()){
                        mutualInf4 = 0.0;
                    }
                    Double mutualInf = mutualInf1 + mutualInf2 + mutualInf3 + mutualInf4;
                    
                    if(mutualInf > max){
                        max = mutualInf;
                    }
                    if(mutualInf < min){
                        min = mutualInf;
                    }
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = mutualInf;
                    adjacencyListTerms[keyA].AddNeighbor(indVal1);
                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = mutualInf;
                    adjacencyListTerms[keyB].AddNeighbor(indVal2);
                }
            }
            System.out.println("Max Mutual Information: " + max);
            System.out.println("Min Mutual Information: " + min);

            if(relative == true){
                threshold = ((max - min) * threshold) + min;
            }
            for(int term=0;term<numTerms;term++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term].getNeighbors();
                for(int neighbor=0;neighbor<neighbors.size();neighbor++){
                    if(neighbors.get(neighbor).value < threshold){
                        neighbors.remove(neighbor);
                        neighbor--;
                    }
                }
            }                  

            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        neighbors.get(term2).value += min;
                    }
                }
            }
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }

        System.out.println("Term-term network were generated.");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Mutual Information as similarity measure and TopK aprroach
    public static Neighbor[] GenerateMutualInformationNetworkTopK(File arqIn, int numTerms, int k){
        System.out.println("Loading probability file...");
        System.out.println("Mutual Information - TopK");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        double probs[] = new double[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    
                    Double mutualInf1 = mutualInf1 = probAB * (Math.log10(probAB/(probs[keyA] * probs[keyB]))/0.301);
                    if(mutualInf1.isNaN()){
                        mutualInf1 = 0.0;
                    }
                    if(mutualInf1.isInfinite()){
                        mutualInf1 = 0.0;
                    }
                    Double mutualInf2 = mutualInf2 = (probs[keyA] - probAB) * (Math.log10((probs[keyA] - probAB)/(probs[keyA] * (1-probs[keyB])))/0.301);
                    if(mutualInf2.isNaN()){
                        mutualInf2 = 0.0;
                    }
                    if(mutualInf2.isInfinite()){
                        mutualInf2 = 0.0;
                    }
                    Double mutualInf3 = (probs[keyB] - probAB) * (Math.log10((probs[keyB] - probAB)/((1 - probs[keyA])* probs[keyB]))/0.301);
                    if(mutualInf3.isNaN()){
                        mutualInf3 = 0.0;
                    }
                    if(mutualInf3.isInfinite()){
                        mutualInf3 = 0.0;
                    }
                    Double mutualInf4 = (1 - probs[keyA] - probs[keyB] + probAB) * (Math.log10((1 - probs[keyA] - probs[keyB] + probAB)/((1-probs[keyA])*(1-probs[keyB])))/0.301);;
                    if(mutualInf4.isNaN()){
                        mutualInf4 = 0.0;
                    }
                    if(mutualInf4.isInfinite()){
                        mutualInf4 = 0.0;
                    }
                    Double mutualInf = mutualInf1 + mutualInf2 + mutualInf3 + mutualInf4;
                    
                    if(mutualInf < min){
                        min = mutualInf;
                    }
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = mutualInf;
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[keyA].getNeighbors();
                    if(neighbors.size()== 0){
                        neighbors.add(indVal1);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(mutualInf == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(mutualInf<neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                flag = true;
                                break;
                            }
                        }
                        if(equal == false){
                            if(flag == false){
                                neighbors.add(indVal1);
                            }
                        }
                        
                    }

                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = mutualInf;
                    neighbors = adjacencyListTerms[keyB].getNeighbors();
                    if(neighbors.size()==0){
                        neighbors.add(indVal2);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(mutualInf == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(mutualInf<neighbors.get(pos).value){
                                neighbors.add(pos,indVal2);
                                flag = true;
                                break;
                            }
                        }
                    }
                }
            }
        
            IndexValue[] maxima = new IndexValue[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                IndexValue indVal = new IndexValue();
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo].getNeighbors();
                if(neighbors.size() != 0){
                    indVal = neighbors.get(neighbors.size() - 1);
                    maxima[termo] = indVal;
                }            
            }

            ArrayList<Double>[] topKvalues = new ArrayList[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                topKvalues[termo] = new ArrayList<Double>();
            }
            for(int termo1=0;termo1<numTerms;termo1++){
                int count = 0;
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo1].getNeighbors();
                for(int termo2=neighbors.size()-1;termo2>=0;termo2--){
                    IndexValue indVal = neighbors.get(termo2);
                    if(!topKvalues[termo1].contains(indVal.value)){
                        topKvalues[termo1].add(indVal.value);
                        count++;
                        if(count>=k){
                            break;
                        }
                    }
                }
            }

                       
            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                for(int term2=0;term2<neighbors.size();term2++){
                    IndexValue indVal = neighbors.get(term2);
                    if(!topKvalues[term1].contains(indVal.value)){
                        neighbors.remove(0);
                        term2--;
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<Double> topKvaluesT1 = topKvalues[term1];
                for(int valueT1=0;valueT1<topKvaluesT1.size();valueT1++){
                   double topKT1 = topKvaluesT1.get(valueT1);
                    ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighborsT1.size();term2++){
                        IndexValue indVal = neighborsT1.get(term2);
                        ArrayList<Double> topKvaluesT2 = topKvalues[indVal.index];
                        if(!topKvaluesT2.contains(topKT1)){
                            neighborsT1.remove(term2);
                            term2--;
                        }
                    }    
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                if(neighborsT1.size() == 1){
                    if(neighborsT1.get(0) == null){
                        neighborsT1.remove(0);
                    }
                }
                if(neighborsT1.size() == 0){
                    if(maxima[term1] != null){
                        neighborsT1.add(maxima[term1]);
                    }
                }
            }
            
            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null){continue;}
                        neighbors.get(term2).value += min;
                    }
                }
            }
            
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }
        
        System.out.println("Term-term relations were generated.");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Kappa as similarity measure and Threshold aprroach
    public static Neighbor[] GenerateKappaNetworkThreshold(File arqIn, int numTerms, double threshold, boolean relative){
        System.out.println("Loading probability file...");
        System.out.println("Kappa - Threshold");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];;
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double probs[] = new double[numTerms];
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    
                    double probA = probs[keyA];
                    double probB = probs[keyB];
                    double numerator = probAB + (1 - probA - probB + probAB) - (probA * probB) - ((1-probA)*(1-probB));
                    double denominator = 1 - (probA * probB) - ((1 - probA)*(1 - probB));

                    double kappa = 0;
                    if(denominator != 0){
                        kappa = numerator/denominator;
                    }
                    
                    if(kappa <= 0){
                        continue;
                    }
                    
                    if(kappa < min){
                        min = kappa;
                    }
                    if(kappa > max){
                        max = kappa;
                    }
                    

                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = kappa;
                    adjacencyListTerms[keyA].AddNeighbor(indVal1);
                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = kappa;
                    adjacencyListTerms[keyB].AddNeighbor(indVal2);
                }
            }
            
            System.out.println("Max Kappa: " + max);
            System.out.println("Min Kappa: " + min);
            
            
            
            if(relative == true){
                threshold = ((max - min) * threshold) + min;
            }
            for(int term=0;term<numTerms;term++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term].getNeighbors();
                for(int neighbor=0;neighbor<neighbors.size();neighbor++){
                    if(neighbors.get(neighbor).value < threshold){
                        neighbors.remove(neighbor);
                        neighbor--;
                    }
                }
            }
            
            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null){ continue; }
                        neighbors.get(term2).value += min;
                    }
                }
            }
            
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }

        System.out.println("Term-term networks were generated");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Kappa as similarity measure and TopK aprroach
    public static Neighbor[] GenerateKappaNetworkTopK(File arqIn, int numTerms, int k){
        System.out.println("Loading probability file...");
        System.out.println("Kappa - TopK");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        double probs[] = new double[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    
                    double numerator = probAB + (1 - probs[keyA] - probs[keyB] + probAB) - (probs[keyA] * probs[keyB]) - ((1-probs[keyA])*(1-probs[keyB]));
                    double denominator = 1 - (probs[keyA] * probs[keyB]) - ((1 - probs[keyA])*(1 - probs[keyB]));

                    double kappa = 0;
                    if(denominator != 0){
                        kappa = numerator/denominator;
                    }

                    if(kappa < min){
                        min = kappa;
                    }
                    
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = kappa;
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[keyA].getNeighbors();
                    if(neighbors.size()== 0){
                        neighbors.add(indVal1);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(kappa == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(kappa<neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                flag = true;
                                break;
                            }
                        }
                        if(equal == false){
                            if(flag == false){
                                neighbors.add(indVal1);
                            }
                        }
                        
                    }

                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = kappa;
                    neighbors = adjacencyListTerms[keyB].getNeighbors();
                    if(neighbors.size()==0){
                        neighbors.add(indVal2);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(kappa == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(kappa<neighbors.get(pos).value){
                                neighbors.add(pos,indVal2);
                                flag = true;
                                break;
                            }
                        }
                    }
                }
            }
        
            IndexValue[] maxima = new IndexValue[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                IndexValue indVal = new IndexValue();
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo].getNeighbors();
                if(neighbors.size() != 0){
                    indVal = neighbors.get(neighbors.size() - 1);
                    maxima[termo] = indVal;
                }
            }

            ArrayList<Double>[] topKvalues = new ArrayList[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                topKvalues[termo] = new ArrayList<Double>();
            }
            for(int termo1=0;termo1<numTerms;termo1++){
                int count = 0;
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo1].getNeighbors();
                for(int termo2=neighbors.size()-1;termo2>=0;termo2--){
                    IndexValue indVal = neighbors.get(termo2);
                    if(!topKvalues[termo1].contains(indVal.value)){
                        topKvalues[termo1].add(indVal.value);
                        count++;
                        if(count>=k){
                            break;
                        }
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                for(int term2=0;term2<neighbors.size();term2++){
                    IndexValue indVal = neighbors.get(term2);
                    if(!topKvalues[term1].contains(indVal.value)){
                        neighbors.remove(0);
                        term2--;
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<Double> topKvaluesT1 = topKvalues[term1];
                for(int valueT1=0;valueT1<topKvaluesT1.size();valueT1++){
                   double topKT1 = topKvaluesT1.get(valueT1);
                    ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighborsT1.size();term2++){
                        IndexValue indVal = neighborsT1.get(term2);
                        ArrayList<Double> topKvaluesT2 = topKvalues[indVal.index];
                        if(!topKvaluesT2.contains(topKT1)){
                            neighborsT1.remove(term2);
                            term2--;
                        }
                    }    
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                if(neighborsT1.size() == 0){
                    neighborsT1.add(maxima[term1]);
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                if(neighborsT1.size() == 1){
                    if(neighborsT1.get(0) == null){
                        neighborsT1.remove(0);
                    }
                }
                if(neighborsT1.size() == 0){
                    if(maxima[term1] != null){
                        neighborsT1.add(maxima[term1]);
                    }
                }
            }

            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null) {continue;}
                        neighbors.get(term2).value += min;
                    }
                }
            }

        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }
        
        System.out.println("Term-term networks were generated.");
        
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Shapiro as similarity measure and Threshold aprroach        
    public static Neighbor[] GenerateShapiroNetworkThreshold(File arqIn, int numTerms, double threshold, boolean relative){
        System.out.println("Loading probability file...");
        System.out.println("Shapiro - Threshold");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];;
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double probs[] = new double[numTerms];
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }

                    double probA = probs[keyA];
                    double probB = probs[keyB];

                    double shapiro = probAB - (probA*probB);
                    
                    if(shapiro <= 0){
                        continue;
                    }
                    
                    if(shapiro > max){
                        max = shapiro;
                    }
                    if(shapiro < min){
                        min = shapiro;
                    }
                    
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = shapiro;
                    adjacencyListTerms[keyA].AddNeighbor(indVal1);
                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = shapiro;
                    adjacencyListTerms[keyB].AddNeighbor(indVal2);
                }
            }
            
            System.out.println("Max Shapiro: " + max);
            System.out.println("Min Shapiro: " + min);
            
            
            
            if(relative == true){
                threshold = ((max - min) * threshold) + min;
            }
            for(int term=0;term<numTerms;term++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term].getNeighbors();
                for(int neighbor=0;neighbor<neighbors.size();neighbor++){
                    if(neighbors.get(neighbor).value < threshold){
                        neighbors.remove(neighbor);
                        neighbor--;
                    }
                }
            }

            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null){ continue; }
                        neighbors.get(term2).value += min;
                    }
                }
            }

                        
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }
        
        System.out.println("Term-term relations were generated");
        return adjacencyListTerms;
    }
    
    // Funtion to generate term-term relations considering Shapiro as similarity measure and TopK aprroach    
    public static Neighbor[] GenerateShapiroNetworkTopK(File arqIn, int numTerms, int k){
        System.out.println("Loading probability file...");
        System.out.println("Shapiro - TopK");
        Neighbor[] adjacencyListTerms = new Neighbor[numTerms];
        double probs[] = new double[numTerms];
        for(int termo=0;termo<numTerms;termo++){
            adjacencyListTerms[termo] = new Neighbor();
        }
        
        double min = Double.MAX_VALUE;
        
        try{
            BufferedReader arqEnt = new BufferedReader(new FileReader(arqIn));
            String line = "";
            while((line = arqEnt.readLine())!=null){
                if(!line.contains(",")){
                    String[] parts = line.split(" ");
                    
                    int pos;
                    try{
                        pos = Integer.parseInt(parts[0]);
                    }catch(Exception e){
                        continue;
                    }
                    
                    try{
                        probs[pos] = Double.parseDouble(parts[1]);
                    }catch(Exception e){
                        probs[pos] = 0;
                    }
                }else{
                    String[] parts1 = line.split(" ");
                    String[] parts2 = parts1[0].split(",");
                    int keyA = Integer.parseInt(parts2[0]);
                    int keyB = Integer.parseInt(parts2[1]);
                    double probAB = 0;
                    try{
                        probAB = Double.parseDouble(parts1[1]);
                    }catch(Exception e){ }
                    double shapiro = probAB - (probs[keyA] * probs[keyB]);
                    IndexValue indVal1 = new IndexValue();
                    indVal1.index = keyB;
                    indVal1.value = shapiro;
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[keyA].getNeighbors();
                    
                    if(shapiro < min){
                        min = shapiro;
                    }
                    
                    if(neighbors.size()== 0){
                        neighbors.add(indVal1);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(probAB == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(probAB<neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                flag = true;
                                break;
                            }
                        }
                        if(equal == false){
                            if(flag == false){
                                neighbors.add(indVal1);
                            }
                        }
                        
                    }

                    IndexValue indVal2 = new IndexValue();
                    indVal2.index = keyA;
                    indVal2.value = probAB;
                    neighbors = adjacencyListTerms[keyB].getNeighbors();
                    if(neighbors.size()==0){
                        neighbors.add(indVal2);
                    }else{
                        boolean flag = false;
                        boolean equal = false;
                        for(int pos=0;pos<neighbors.size();pos++){
                            if(probAB == neighbors.get(pos).value){
                                neighbors.add(pos,indVal1);
                                equal = true;
                                break;
                            }
                            if(probAB<neighbors.get(pos).value){
                                neighbors.add(pos,indVal2);
                                flag = true;
                                break;
                            }
                        }
                    }
                }
            }
        
            IndexValue[] maxima = new IndexValue[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                IndexValue indVal = new IndexValue();
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo].getNeighbors();
                if(neighbors.size() != 0){
                    indVal = neighbors.get(neighbors.size() - 1);
                    maxima[termo] = indVal;
                }
            }

            ArrayList<Double>[] topKvalues = new ArrayList[numTerms];
            for(int termo=0;termo<numTerms;termo++){
                topKvalues[termo] = new ArrayList<Double>();
            }
            for(int termo1=0;termo1<numTerms;termo1++){
                int count = 0;
                ArrayList<IndexValue> neighbors = adjacencyListTerms[termo1].getNeighbors();
                for(int termo2=neighbors.size()-1;termo2>=0;termo2--){
                    IndexValue indVal = neighbors.get(termo2);
                    if(!topKvalues[termo1].contains(indVal.value)){
                        topKvalues[termo1].add(indVal.value);
                        count++;
                        if(count>=k){
                            break;
                        }
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                for(int term2=0;term2<neighbors.size();term2++){
                    IndexValue indVal = neighbors.get(term2);
                    if(!topKvalues[term1].contains(indVal.value)){
                        neighbors.remove(0);
                        term2--;
                    }
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<Double> topKvaluesT1 = topKvalues[term1];
                for(int valueT1=0;valueT1<topKvaluesT1.size();valueT1++){
                   double topKT1 = topKvaluesT1.get(valueT1);
                    ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighborsT1.size();term2++){
                        IndexValue indVal = neighborsT1.get(term2);
                        ArrayList<Double> topKvaluesT2 = topKvalues[indVal.index];
                        if(!topKvaluesT2.contains(topKT1)){
                            neighborsT1.remove(term2);
                            term2--;
                        }
                    }    
                }
            }

            for(int term1=0;term1<numTerms;term1++){
                ArrayList<IndexValue> neighborsT1 = adjacencyListTerms[term1].getNeighbors();
                if(neighborsT1.size() == 1){
                    if(neighborsT1.get(0) == null){
                        neighborsT1.remove(0);
                    }
                }
                if(neighborsT1.size() == 0){
                    if(maxima[term1] != null){
                        neighborsT1.add(maxima[term1]);
                    }
                }
            }

            if(min < 0){
                min = min * -1;    
                for(int term1=0;term1<numTerms;term1++){
                    ArrayList<IndexValue> neighbors = adjacencyListTerms[term1].getNeighbors();
                    for(int term2=0;term2<neighbors.size();term2++){
                        if(neighbors.get(term2) == null){continue;}
                        neighbors.get(term2).setValue(neighbors.get(term2).getValue() + min);
                    }
                }
            }
        
        }catch(Exception e){
            System.out.println("Error when generating term-term relations.");
            e.printStackTrace();
            System.exit(0);
        }
        
        System.out.println("Term-term relations were generated.");
        return adjacencyListTerms;
    }
}
